package windTurbine;

/**
 * This class contains methods used to calculate the aerodynamic coefficients of drag and lift.
 * The airfoil model used is a NACA 2412 (naca2412-il) with RE=200,000 and Ncrit=9.
 * 
 * @author Mitchell Keeley, Chaitanya Varier
 * @version 05/15/2016
 */

public class Coefficients {
	
	private static final double PI = Math.PI;
	
	/**
	 * Returns the lift coefficient of the airfoil as a function of
	 * the angle of attack in radians. This is the curve-fitted representation of the
	 * extended polar. The extended polar was generated by extrapolating the data taken
	 * from the xFoil predicted polar for the airfoil under the given aerodynamic constraints using the
	 * Viterna method to extend the alpha range from -pi to pi radians.<br><br>
	 * 
	 * The mathematical representation of this method is a piecewise function
	 * consisting of a sum of sines and cosines generated through Fourier transform when<br><br> 
	 * -0.196349541 rad &lt; alpha &lt;= -0.161442956 rad, when<br> -0.161442956 rad &lt; alpha &lt;= 0 rad,
	 * when<br> 0 rad &lt; alpha &lt;= 0.23536 rad, when<br> 0.2487090 rad &lt; alpha &lt;= 0.296706 rad, and 
	 * when<br> 2.558 rad &lt; alpha &lt;= pi rad.<br><br>
	 * 
	 * The function consists of polynomial terms when<br><br> 
	 * -pi rad &lt;= alpha &lt;= -0.196349541 rad, when<br>
	 * 0.23536 rad &lt; alpha &lt;= 0.248709 rad, and when<br>
	 * 0.296706 rad &lt; alpha &lt;= 2.558 rad.<br>
	 * 
	 * @param alpha Angle of attack in radians (any real angle).
	 * @return Coefficient of lift as function of angle alpha.
	 */
	
	public static double getCoefficientLift (double alpha) {

		if (alpha < -PI) {
			return getCoefficientLift(alpha+2*PI);
		}

		if (alpha > PI) {
			return getCoefficientLift(alpha-2*PI);
		}
		
		if (alpha >= -PI && alpha <= -2.617993878) {
			return -4.53*alpha*alpha*alpha-43.18*alpha*alpha-134.5*alpha-136.8002-0.0331272294475;
		}
		
		if (alpha > -2.617993878 && alpha < -0.34906585) {
			return -0.1382*alpha*alpha*alpha*alpha*alpha-
					1.0964*alpha*alpha*alpha*alpha-
					3.0056*alpha*alpha*alpha-
					3.2776*alpha*alpha-
					1.788*alpha-
					1.01973983808;
		}
		
		if (alpha >= -0.34906585 && alpha <= -0.196349541) {
			return 0.345*alpha-0.5632;
		}
		
		if (alpha > -0.196349541 && alpha <= -0.161442956) {
			return -0.7268+0.04089*Math.cos(alpha*90)+
					0.06894*Math.sin(alpha*90)-
					0.00935*Math.cos(180*alpha)+
					0.01487*Math.sin(180*alpha);
		}
		
		if (alpha > -0.161442956 && alpha <= 0) {
			return 0.1978+0.5245*Math.cos(alpha*17.2)+0.9687*Math.sin(alpha*17.2)-
					0.4208*Math.cos(2*alpha*17.2)+0.06007*Math.sin(2*alpha*17.2)-
					0.016*Math.cos(3*alpha*17.2)-0.1282*Math.sin(3*alpha*17.2)+
					0.00114686568;
		}
		
		if (alpha > 0 && alpha <= 0.23536) {
			return 1.01067*(14.48*Math.sin(11.01*alpha-0.1653)+
					13.37*Math.sin(11.4*alpha+2.941)+
					0.01288*Math.sin(55.38*alpha+1.35)
					-0.01026235261);
		}
		
		if (alpha > 0.23536 && alpha <= 0.248709) {
			return 1.324566+0.01566*alpha;
		}
		
		if (alpha > 0.248709 && alpha <= 0.296706) {
			return 1.152+0.06825*Math.cos(alpha*54.38)+0.177*Math.sin(alpha*54.38)+
					0.03451*Math.cos(2*alpha*54.38)+0.004357*Math.sin(2*alpha*54.38);
		}
		
		if (alpha > 0.296706 && alpha <= 2.558) {
			return 0.2249*alpha*alpha*alpha*alpha*alpha*alpha-
					2.2324*alpha*alpha*alpha*alpha*alpha+
					8.6871*alpha*alpha*alpha*alpha-
					16.423*alpha*alpha*alpha+
					15.184*alpha*alpha-
					6.8925*alpha+2.1175079746;
		} else {
			return -0.3942-0.3309*Math.cos(alpha*4.744)+0.08493*Math.sin(alpha*4.744)
					+0.08745*Math.cos(2*alpha*4.744)-0.1064*Math.sin(2*alpha*4.744);
		}

	}

	/**
	 * Returns the drag coefficient of the airfoil as a function of
	 * the angle of attack in radians. This is the curve-fitted representation of the
	 * extended polar. The extended polar was generated by extrapolating the data taken
	 * from the xFoil predicted polar for the airfoil under the given aerodynamic constraints using the
	 * Viterna method to extend the alpha range from -pi to pi radians.
	 * 
	 * The mathematical representation of this method is a piecewise function
	 * consisting of a sum of sines and cosines generated through Fourier transform when<br><br> 
	 * -pi rad &lt;= alpha &lt; -0.196350 rad, and when<br> 0.349066 rad &lt; alpha &lt;= pi rad.<br><br>
	 * 
	 * The function consists of polynomial terms when<br><br> 
	 * -0.196350 rad &lt;= alpha &lt;= 0.349066 rad.
	 * 
	 * @param alpha Angle of attack in radians (any real angle).
	 * @return Coefficient of lift as function of angle alpha.
	 * 
	 * @param alpha Angle of attack in radians (any real angle).
	 * @return Coefficient of drag as function of angle alpha.
	 */
	
	public static double getCoefficientDrag (double alpha) {

		if (alpha < -PI) {
			return getCoefficientDrag(alpha+2*PI);
		}

		if (alpha > PI) {
			return getCoefficientDrag(alpha-2*PI);
		}
		
		if (alpha >= -PI && alpha < -0.196350) {
			return 0.661933637102-0.6336*Math.cos(alpha*1.992)-0.007707*Math.sin(alpha*1.992);
		}
		
		if (alpha >= -0.196350 && alpha < 0.296706) {
			return 18090*alpha*alpha*alpha*alpha*alpha*alpha*alpha*alpha-
					6336*alpha*alpha*alpha*alpha*alpha*alpha*alpha-
					434.3*alpha*alpha*alpha*alpha*alpha*alpha+
					269.9*alpha*alpha*alpha*alpha*alpha*+
					6.546*alpha*alpha*alpha*alpha-
					3.696*alpha*alpha*alpha+
					0.5564*alpha*alpha-
					0.01205*alpha+0.009997;
		} 
		
		if (alpha >= 0.296706 && alpha <= 0.349066) {
			return 0.7668*alpha-0.0894;
		} else {
			return 0.65978759232-0.6337*Math.cos(alpha*1.992)+0.007889*Math.sin(alpha*1.992);
		}
		

	}

}
