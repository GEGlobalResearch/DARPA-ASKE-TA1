uri "http://sadl.org/WindTurbineExtract.dialog" alias windTurbineExtract.

import "http://aske.ge.com/WindTurbine".
import "http://sadl.org/Coefficients.dialog".

//Extract from "file:///Users/alfredo/Documents/git/DARPA-ASKE-TA2/KnowledgeGraph/ASKE_P2/ExtractedModels/Sources/WindTurbine-modified.java".
CM: "The following classes are suggested for the domain model:".
CM: Ratio (see "http://www.wikidata.org/entity/Q3481047") is a type of ScientificConcept.
CM: "Parsing code file 'WindTurbine-modified.java'".
CM: External WindTurbine.getPowerCoefficient() returns double(CoefficientOfPower): "http://windTurbine/WindTurbine#WindTurbine.getPowerCoefficient".
CM: WindTurbine.getPowerCoefficient
 has dependsOn Coefficients.getCoefficientLift,
     has dependsOn WindTurbine.getChordLength,
     has dependsOn Coefficients.getCoefficientDrag,
     has dependsOn WindTurbine.getTwist,
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "e", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double e = Math.E;", with language Java)
       with declaration (a Script with script "e = Math.E", with language Python),
       with declaration (a Script with script "e = tf.e", with language Python-TF),
       with declaration (a Script with script "e = np.e", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "B", with dataType "http://www.w3.org/2001/XMLSchema#int", 
       with declaration (a Script with script "int B;", with language Java)
       with declaration (a Script with script "B = 0", with language Python),
       with declaration (a Script with script "B = 0", with language Python-TF),
       with declaration (a Script with script "B = 0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "DIFF_THRESHOLD", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double DIFF_THRESHOLD = 1e-6;", with language Java)
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python-TF),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "DIFF_THRESHOLD", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double DIFF_THRESHOLD = 1e-6;", with language Java)
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python-TF),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "PI", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double PI = Math.PI;", with language Java)
       with declaration (a Script with script "PI = Math.PI", with language Python),
       with declaration (a Script with script "PI = tf.pi", with language Python-TF),
       with declaration (a Script with script "PI = np.pi", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double R;", with language Java)
       with declaration (a Script with script "R = 0.0", with language Python),
       with declaration (a Script with script "R = 0.0", with language Python-TF),
       with declaration (a Script with script "R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "dlambda_r", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double dlambda_r;", with language Java)
       with declaration (a Script with script "dlambda_r = 0.0", with language Python),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-TF),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "radius", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double radius = 0.0;", with language Java)
       with declaration (a Script with script "radius = dr", with language Python),
       with declaration (a Script with script "radius = dr", with language Python-TF),
       with declaration (a Script with script "radius = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "lambda_R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double lambda_R;", with language Java)
       with declaration (a Script with script "lambda_R = 0.0", with language Python),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-TF),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "Omega", with dataType "http://www.w3.org/2001/XMLSchema#double",
     	 with augmentedType (a SemanticType with semType RotationalSpeed)
       with declaration (a Script with script "double Omega;", with language Java)
       with declaration (a Script with script "Omega = 0.0", with language Python),
       with declaration (a Script with script "Omega = 0.0", with language Python-TF),
       with declaration (a Script with script "Omega = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "lambda_R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double lambda_R;", with language Java)
       with declaration (a Script with script "lambda_R = 0.0", with language Python),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-TF),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "dr", with dataType "http://www.w3.org/2001/XMLSchema#double",
//     	 with augmentedType (a SemanticType with semType RadiusIncrement)
       with declaration (a Script with script "double dr = 0.01;", with language Java)
       with declaration (a Script with script "dr = 0.01", with language Python),
       with declaration (a Script with script "dr = 0.01", with language Python-TF),
       with declaration (a Script with script "dr = 0.01", with language Python-NumPy))
    ,
     has expression (a Script with language Java, with script 
    "	public double getPowerCoefficient () {
		
		// Let C_Ptot be the running sum for the coefficient of power
		double C_Ptot = 0;
		double lambda_r;
		double phi;
			
		double alpha;
		double C_L;
		double C_D;
		double C_t;
		double C_n;
		double sigmaPrime;
		double a_next;
		double aPrime_next;
		double aPrime;
		double a;
		double F_tilde;
		double f;
		double F;
		int counter = 0;
		
		System.out.println(\"------------Intermediary Values-------------\");
		System.out.println(\"radial position(m)\ta\t\t\taPrime\");

		for (double radius = dr; radius <= R; radius += dr) {
			counter = 0;

			//---------Calculate a and aPrime at current radial position-----------

			// Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
			lambda_r = Omega*radius;
			phi = 0;
			
			// Look up C_d(alpha) and C_l(alpha) from the Coefficients class
			sigmaPrime = B * getChordLength(radius) /(2*PI*radius); // Calculate local solidity
			a_next = 1./3;
			aPrime_next = 0.0;
			aPrime = 1;
			a = 1;
			F_tilde = 0;
			
			// Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
			while (Math.abs(a_next-a) > DIFF_THRESHOLD && Math.abs(aPrime_next-aPrime) > DIFF_THRESHOLD && counter < 30) {
				
				/* Set the current values of a and aPrime to the values of a and aPrime calculated
				 * in the previous iteration.
				 */
				a = a_next;
				aPrime = aPrime_next;
				
				// Calculate angle between reference plane and relative wind
				phi = Math.atan((1-a)/(lambda_r*(1+aPrime)));
				
				// Calculate angle of attack, defined as angle between chord line and relative wind
				alpha = phi - getTwist(radius);
				
				// Look up C_d(alpha) and C_l(alpha)
				C_L = Coefficients.getCoefficientLift(alpha);
				C_D = Coefficients.getCoefficientDrag(alpha);
				C_t = C_L*Math.sin(phi) - C_D*Math.cos(phi);
				C_n = C_L*Math.cos(phi) + C_D*Math.sin(phi);
				
				// Calculate tip loss correction factor
				f = B*(R-radius)/(2*radius*Math.sin(phi));
				F = 2/PI*Math.acos(Math.pow(e, -f));
				F_tilde = F*Math.max(1.0, (1-a/4*(5-3*a))/(1-a));
				
				/* Cancel the effect of the tip loss correction factor 
				 * if the current segment is at the end of the blade
				 */
				if (Math.abs(R-radius)<1e-6 || Double.isNaN(F_tilde)) {
					F_tilde = 1;
					F = 1;
				}
				
				// Calculate the new values of a and aPrime
				a_next = 1/(4*F_tilde*(Math.sin(phi))*(Math.sin(phi))/(C_n*sigmaPrime) + 1);
				aPrime_next = 1/(4*F*(Math.sin(phi))*(Math.cos(phi))/(C_t*sigmaPrime) - 1);
				
				counter = counter + 1;
			}
			
			System.out.printf(\"%.2f\t\t\t\" + \"%.6f\t\t\" + \"%.6f\n\", radius, a_next, aPrime_next);
			

			//--------Calculate dC_P and add it to the running sum for the power coefficient---------
			
			C_Ptot += 8/(lambda_R*lambda_R)*F_tilde*aPrime*(1-a)*lambda_r*lambda_r*lambda_r*dlambda_r;
			
		}
		
		//--------Return the total sum of all the C_P contributions from each blade segment---------
		
		return C_Ptot*100;

	}"),
     has expression (a Script with language Python, with script 
    "def getPowerCoefficient():
    \"\"\" generated source for method getPowerCoefficient \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    counter = 0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        counter = 0
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        F_tilde = 0
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while Math.abs(a_next - a) > DIFF_THRESHOLD and Math.abs(aPrime_next - aPrime) > DIFF_THRESHOLD and counter < 30:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = Math.atan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * Math.sin(phi) - C_D * Math.cos(phi)
            C_n = C_L * Math.cos(phi) + C_D * Math.sin(phi)
            # // Calculate tip loss correction factor
            f = B * (R - radius) / (2 * radius * Math.sin(phi))
            F = 2 / PI * Math.acos(Math.pow(e, -f))
            F_tilde = F * Math.max(1.0, (1 - a / 4 * (5 - 3 * a)) / (1 - a))
            # /* Cancel the effect of the tip loss correction factor 
            # 				 * if the current segment is at the end of the blade
            # 				 */
            if Math.abs(R - radius) < 1e-6 or Double.isNaN(F_tilde):
                F_tilde = 1
                F = 1
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * F_tilde * (Math.sin(phi)) * (Math.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * F * (Math.sin(phi)) * (Math.cos(phi)) / (C_t * sigmaPrime) - 1)
            counter = counter + 1
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * F_tilde * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate tip loss correction factor
    # /* Cancel the effect of the tip loss correction factor 
    # 				 * if the current segment is at the end of the blade
    # 				 */
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
"),
     has expression (a Script with language Python-TF, with script 
    "def getPowerCoefficient():
    \"\"\" generated source for method getPowerCoefficient \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    counter = 0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        counter = 0
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        F_tilde = 0
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while tf.abs(a_next - a) > DIFF_THRESHOLD and tf.abs(aPrime_next - aPrime) > DIFF_THRESHOLD and counter < 30:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = tf.atan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * tf.sin(phi) - C_D * tf.cos(phi)
            C_n = C_L * tf.cos(phi) + C_D * tf.sin(phi)
            # // Calculate tip loss correction factor
            f = B * (R - radius) / (2 * radius * tf.sin(phi))
            F = 2 / PI * tf.acos(tf.pow(e, -f))
            F_tilde = F * tf.maximum(1.0, (1 - a / 4 * (5 - 3 * a)) / (1 - a))
            # /* Cancel the effect of the tip loss correction factor 
            # 				 * if the current segment is at the end of the blade
            # 				 */
            if tf.abs(R - radius) < 1e-6 or tf.is_nan(F_tilde):
                F_tilde = 1
                F = 1
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * F_tilde * (tf.sin(phi)) * (tf.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * F * (tf.sin(phi)) * (tf.cos(phi)) / (C_t * sigmaPrime) - 1)
            counter = counter + 1
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * F_tilde * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate tip loss correction factor
    # /* Cancel the effect of the tip loss correction factor 
    # 				 * if the current segment is at the end of the blade
    # 				 */
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
"),
     has expression (a Script with language Python-NumPy, with script 
    "def getPowerCoefficient():
    \"\"\" generated source for method getPowerCoefficient \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    counter = 0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        counter = 0
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        F_tilde = 0
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while np.abs(a_next - a) > DIFF_THRESHOLD and np.abs(aPrime_next - aPrime) > DIFF_THRESHOLD and counter < 30:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = np.arctan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * np.sin(phi) - C_D * np.cos(phi)
            C_n = C_L * np.cos(phi) + C_D * np.sin(phi)
            # // Calculate tip loss correction factor
            f = B * (R - radius) / (2 * radius * np.sin(phi))
            F = 2 / PI * np.arccos(np.power(e, -f))
            F_tilde = F * np.maximum(1.0, (1 - a / 4 * (5 - 3 * a)) / (1 - a))
            # /* Cancel the effect of the tip loss correction factor 
            # 				 * if the current segment is at the end of the blade
            # 				 */
            if np.abs(R - radius) < 1e-6 or np.isnan(F_tilde):
                F_tilde = 1
                F = 1
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * F_tilde * (np.sin(phi)) * (np.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * F * (np.sin(phi)) * (np.cos(phi)) / (C_t * sigmaPrime) - 1)
            counter = counter + 1
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * F_tilde * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate tip loss correction factor
    # /* Cancel the effect of the tip loss correction factor 
    # 				 * if the current segment is at the end of the blade
    # 				 */
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
").
CM: External WindTurbine.getTwist(double pos(RadialPosition)) returns double(Twist): "http://windTurbine/WindTurbine#WindTurbine.getTwist".
CM: WindTurbine.getTwist
 has implicitInput (an ImplicitDataDescriptor with localDescriptorName "R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double R;", with language Java)
       with declaration (a Script with script "R = 0.0", with language Python),
       with declaration (a Script with script "R = 0.0", with language Python-TF),
       with declaration (a Script with script "R = 0.0", with language Python-NumPy))
    ,
     has expression (a Script with language Java, with script 
    "	private double getTwist (double pos) {

		return 0.02*3/R*Math.log(pos)/Math.log(0.3);
		
	}"),
     has expression (a Script with language Python, with script 
    "def getTwist( pos):
    \"\"\" generated source for method getTwist \"\"\"
    return 0.02 * 3 / R * Math.log(pos) / Math.log(0.3)
"),
     has expression (a Script with language Python-TF, with script 
    "def getTwist( pos):
    \"\"\" generated source for method getTwist \"\"\"
    return 0.02 * 3 / R * tf.log(pos) / tf.log(0.3)
"),
     has expression (a Script with language Python-NumPy, with script 
    "def getTwist( pos):
    \"\"\" generated source for method getTwist \"\"\"
    return 0.02 * 3 / R * np.log(pos) / np.log(0.3)
").
CM: External WindTurbine.getChordLength(double pos(RadialPosition)) returns double(ChordLength): "http://windTurbine/WindTurbine#WindTurbine.getChordLength".
CM: WindTurbine.getChordLength
 has implicitInput (an ImplicitDataDescriptor with localDescriptorName "R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double R;", with language Java)
       with declaration (a Script with script "R = 0.0", with language Python),
       with declaration (a Script with script "R = 0.0", with language Python-TF),
       with declaration (a Script with script "R = 0.0", with language Python-NumPy))
    ,
     has expression (a Script with language Java, with script 
    "	private double getChordLength (double pos) {

		return R/15-3.0/50*pos;

	}"),
     has expression (a Script with language Python, with script 
    "def getChordLength( pos):
    \"\"\" generated source for method getChordLength \"\"\"
    return R / 15 - 3.0 / 50 * pos
"),
     has expression (a Script with language Python-TF, with script 
    "def getChordLength( pos):
    \"\"\" generated source for method getChordLength \"\"\"
    return R / 15 - 3.0 / 50 * pos
"),
     has expression (a Script with language Python-NumPy, with script 
    "def getChordLength( pos):
    \"\"\" generated source for method getChordLength \"\"\"
    return R / 15 - 3.0 / 50 * pos
").
CM: External WindTurbine.getPowerCoefficientNoTip() returns double(CoefficientOfPower): "http://windTurbine/WindTurbine#WindTurbine.getPowerCoefficientNoTip".
CM: What type does WindTurbine.getPowerCoefficientNoTip return?
CM: WindTurbine.getPowerCoefficientNoTip
 has dependsOn Coefficients.getCoefficientLift,
     has dependsOn WindTurbine.getChordLength,
     has dependsOn WindTurbine.getTwist,
     has dependsOn Coefficients.getCoefficientDrag,
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "Omega", with dataType "http://www.w3.org/2001/XMLSchema#double",
     	 with augmentedType (a SemanticType with semType RotationalSpeed)
       with declaration (a Script with script "double Omega;", with language Java)
       with declaration (a Script with script "Omega = 0.0", with language Python),
       with declaration (a Script with script "Omega = 0.0", with language Python-TF),
       with declaration (a Script with script "Omega = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "PI", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double PI = Math.PI;", with language Java)
       with declaration (a Script with script "PI = Math.PI", with language Python),
       with declaration (a Script with script "PI = tf.pi", with language Python-TF),
       with declaration (a Script with script "PI = np.pi", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "lambda_R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double lambda_R;", with language Java)
       with declaration (a Script with script "lambda_R = 0.0", with language Python),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-TF),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double R;", with language Java)
       with declaration (a Script with script "R = 0.0", with language Python),
       with declaration (a Script with script "R = 0.0", with language Python-TF),
       with declaration (a Script with script "R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "dr", with dataType "http://www.w3.org/2001/XMLSchema#double",
//     	 with augmentedType (a SemanticType with semType RadiusIncrement)
       with declaration (a Script with script "double dr = 0.01;", with language Java)
       with declaration (a Script with script "dr = 0.01", with language Python),
       with declaration (a Script with script "dr = 0.01", with language Python-TF),
       with declaration (a Script with script "dr = 0.01", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "radius", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double radius = dr;", with language Java)
       with declaration (a Script with script "radius = dr", with language Python),
       with declaration (a Script with script "radius = dr", with language Python-TF),
       with declaration (a Script with script "radius = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "DIFF_THRESHOLD", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double DIFF_THRESHOLD = 1e-6;", with language Java)
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python-TF),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "B", with dataType "http://www.w3.org/2001/XMLSchema#int", 
       with declaration (a Script with script "int B;", with language Java)
       with declaration (a Script with script "B = 0", with language Python),
       with declaration (a Script with script "B = 0", with language Python-TF),
       with declaration (a Script with script "B = 0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "dlambda_r", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double dlambda_r;", with language Java)
       with declaration (a Script with script "dlambda_r = 0.0", with language Python),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-TF),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "lambda_R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double lambda_R;", with language Java)
       with declaration (a Script with script "lambda_R = 0.0", with language Python),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-TF),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "DIFF_THRESHOLD", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double DIFF_THRESHOLD = 1e-6;", with language Java)
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python-TF),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-6", with language Python-NumPy))
    ,
     has expression (a Script with language Java, with script 
    "	public double getPowerCoefficientNoTip () {
		
		// Let C_Ptot be the running sum for the coefficient of power
		double C_Ptot = 0;
		double lambda_r;
		double phi;
			
		double alpha;
		double C_L;
		double C_D;
		double C_t;
		double C_n;
		double sigmaPrime;
		double a_next;
		double aPrime_next;
		double aPrime;
		double a;
		double F_tilde;
		double f;
		double F;
		int counter = 0;
		
		System.out.println(\"------------Intermediary Values-------------\");
		System.out.println(\"radial position(m)\ta\t\t\taPrime\");

		for (double radius = dr; radius <= R; radius += dr) {
			counter = 0;

			//---------Calculate a and aPrime at current radial position-----------

			// Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
			lambda_r = Omega*radius;
			phi = 0;
			
			// Look up C_d(alpha) and C_l(alpha) from the Coefficients class
			sigmaPrime = B * getChordLength(radius) /(2*PI*radius); // Calculate local solidity
			a_next = 1./3;
			aPrime_next = 0.0;
			aPrime = 1;
			a = 1;
			
			// Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
			while (Math.abs(a_next-a) > DIFF_THRESHOLD && Math.abs(aPrime_next-aPrime) > DIFF_THRESHOLD && counter < 30) {
				
				/* Set the current values of a and aPrime to the values of a and aPrime calculated
				 * in the previous iteration.
				 */
				a = a_next;
				aPrime = aPrime_next;
				
				// Calculate angle between reference plane and relative wind
				phi = Math.atan((1-a)/(lambda_r*(1+aPrime)));
				
				// Calculate angle of attack, defined as angle between chord line and relative wind
				alpha = phi - getTwist(radius);
				
				// Look up C_d(alpha) and C_l(alpha)
				C_L = Coefficients.getCoefficientLift(alpha);
				C_D = Coefficients.getCoefficientDrag(alpha);
				C_t = C_L*Math.sin(phi) - C_D*Math.cos(phi);
				C_n = C_L*Math.cos(phi) + C_D*Math.sin(phi);
				
				// Calculate the new values of a and aPrime
				a_next = 1/(4*(Math.sin(phi))*(Math.sin(phi))/(C_n*sigmaPrime) + 1);
				aPrime_next = 1/(4*(Math.sin(phi))*(Math.cos(phi))/(C_t*sigmaPrime) - 1);
				
				counter = counter + 1;
			}
			
			System.out.printf(\"%.2f\t\t\t\" + \"%.6f\t\t\" + \"%.6f\n\", radius, a_next, aPrime_next);
			

			//--------Calculate dC_P and add it to the running sum for the power coefficient---------
			
			C_Ptot += 8/(lambda_R*lambda_R)*aPrime*(1-a)*lambda_r*lambda_r*lambda_r*dlambda_r;
			
		}
		
		//--------Return the total sum of all the C_P contributions from each blade segment---------
		
		return C_Ptot*100;

	}"),
     has expression (a Script with language Python, with script 
    "def getPowerCoefficientNoTip():
    \"\"\" generated source for method getPowerCoefficientNoTip \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    counter = 0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        counter = 0
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while Math.abs(a_next - a) > DIFF_THRESHOLD and Math.abs(aPrime_next - aPrime) > DIFF_THRESHOLD and counter < 30:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = Math.atan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * Math.sin(phi) - C_D * Math.cos(phi)
            C_n = C_L * Math.cos(phi) + C_D * Math.sin(phi)
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * (Math.sin(phi)) * (Math.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * (Math.sin(phi)) * (Math.cos(phi)) / (C_t * sigmaPrime) - 1)
            counter = counter + 1
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
"),
     has expression (a Script with language Python-TF, with script 
    "def getPowerCoefficientNoTip():
    \"\"\" generated source for method getPowerCoefficientNoTip \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    counter = 0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        counter = 0
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while tf.abs(a_next - a) > DIFF_THRESHOLD and tf.abs(aPrime_next - aPrime) > DIFF_THRESHOLD and counter < 30:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = tf.atan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * tf.sin(phi) - C_D * tf.cos(phi)
            C_n = C_L * tf.cos(phi) + C_D * tf.sin(phi)
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * (tf.sin(phi)) * (tf.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * (tf.sin(phi)) * (tf.cos(phi)) / (C_t * sigmaPrime) - 1)
            counter = counter + 1
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
"),
     has expression (a Script with language Python-NumPy, with script 
    "def getPowerCoefficientNoTip():
    \"\"\" generated source for method getPowerCoefficientNoTip \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    counter = 0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        counter = 0
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while np.abs(a_next - a) > DIFF_THRESHOLD and np.abs(aPrime_next - aPrime) > DIFF_THRESHOLD and counter < 30:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = np.arctan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * np.sin(phi) - C_D * np.cos(phi)
            C_n = C_L * np.cos(phi) + C_D * np.sin(phi)
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * (np.sin(phi)) * (np.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * (np.sin(phi)) * (np.cos(phi)) / (C_t * sigmaPrime) - 1)
            counter = counter + 1
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
").
CM: "The following methods were found in the extraction:".
CM: External WindTurbine.WindTurbine(double radius(Radius), int numBlades(NumOfBlades), double tipSpeedRatio(TipSpeedRatio)): "http://windTurbine/WindTurbine#WindTurbine.WindTurbine".
CM: WindTurbine.WindTurbine
 has implicitInput (an ImplicitDataDescriptor with localDescriptorName "dr", with dataType "http://www.w3.org/2001/XMLSchema#double",
 	 with augmentedType (a SemanticType with semType RadiusIncrement)
       with declaration (a Script with script "double dr = 0.01;", with language Java)
       with declaration (a Script with script "dr = 0.01", with language Python),
       with declaration (a Script with script "dr = 0.01", with language Python-TF),
       with declaration (a Script with script "dr = 0.01", with language Python-NumPy))
     has implicitOutput (an ImplicitDataDescriptor with localDescriptorName "R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double R;", with language Java)
       with declaration (a Script with script "R = 0.0", with language Python),
       with declaration (a Script with script "R = 0.0", with language Python-TF),
       with declaration (a Script with script "R = 0.0", with language Python-NumPy)),
     has implicitOutput (an ImplicitDataDescriptor with localDescriptorName "lambda_R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double lambda_R;", with language Java)
       with declaration (a Script with script "lambda_R = 0.0", with language Python),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-TF),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-NumPy)),
     has implicitOutput (an ImplicitDataDescriptor with localDescriptorName "dlambda_r", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double dlambda_r;", with language Java)
       with declaration (a Script with script "dlambda_r = 0.0", with language Python),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-TF),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-NumPy)),
     has implicitOutput (an ImplicitDataDescriptor with localDescriptorName "B", with dataType "http://www.w3.org/2001/XMLSchema#int", 
       with declaration (a Script with script "int B;", with language Java)
       with declaration (a Script with script "B = 0", with language Python),
       with declaration (a Script with script "B = 0", with language Python-TF),
       with declaration (a Script with script "B = 0", with language Python-NumPy)),
     has implicitOutput (an ImplicitDataDescriptor with localDescriptorName "Omega", with dataType "http://www.w3.org/2001/XMLSchema#double",
     	 with augmentedType (a SemanticType with semType RotationalSpeed)
       with declaration (a Script with script "double Omega;", with language Java)
       with declaration (a Script with script "Omega = 0.0", with language Python),
       with declaration (a Script with script "Omega = 0.0", with language Python-TF),
       with declaration (a Script with script "Omega = 0.0", with language Python-NumPy)),
     has expression (a Script with language Java, with script 
    "	public WindTurbine(double radius, int numBlades, double tipSpeedRatio) {
		self.R = radius;
		self.B = numBlades;
		self.lambda_R = tipSpeedRatio;
		self.Omega = lambda_R/R;
		self.dlambda_r = Omega*dr;
	}"),
     has expression (a Script with language Python, with script 
    "def __init__( radius, numBlades, tipSpeedRatio):
    \"\"\" generated source for method __init__ \"\"\"
    self.R = radius
    self.B = numBlades
    self.lambda_R = tipSpeedRatio
    self.Omega = lambda_R / R
    self.dlambda_r = Omega * dr
"),
     has expression (a Script with language Python-TF, with script 
    "def __init__( radius, numBlades, tipSpeedRatio):
    \"\"\" generated source for method __init__ \"\"\"
    self.R = radius
    self.B = numBlades
    self.lambda_R = tipSpeedRatio
    self.Omega = lambda_R / R
    self.dlambda_r = Omega * dr
"),
     has expression (a Script with language Python-NumPy, with script 
    "def __init__( radius, numBlades, tipSpeedRatio):
    \"\"\" generated source for method __init__ \"\"\"
    self.R = radius
    self.B = numBlades
    self.lambda_R = tipSpeedRatio
    self.Omega = lambda_R / R
    self.dlambda_r = Omega * dr
").
