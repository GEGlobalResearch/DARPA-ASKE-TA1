 uri "http://sadl.org/extractWithDM.dialog" alias extwdm.
 
 import "http://aske.ge.com/WindTurbine".
 
 
Extract from "file:/C:/Users/200005201/sadl3-master2/runtime-New_configuration/Wind.clean/ExtractedModels/Sources/Coefficients-modified.java".
CM: "Parsing code file 'Coefficients-modified.java'".
CM: "The following domain ontology contribution was extracted from code comments:".
CM: Attack is a class, described by alpha_angle with values of type AlphaAngle.
CM: Representation is a class.
CM: DragAndLift is a class, described by aerodynamic_coefficients with values of type AerodynamicCoefficients.
CM: AlphaAngle is a type of UnittedQuantity.
    unit of AlphaAngle always has value "radians".
CM: Function is a class.
CM: AerodynamicCoefficients is a class.
CM: Coefficient is a class.
CM: Angle is a type of UnittedQuantity, described by function with values of type Function.
    unit of Angle always has value "radians".
CM: Polar is a class, described by representation with values of type Representation.
CM: Airfoil is a class, described by drag_coefficient with values of type DragCoefficient.
CM: AngleAlpha is a class, described by function with values of type Function.
CM: Lift is a class, described by coefficient with values of type Coefficient.
CM: Drag is a class, described by coefficient with values of type Coefficient.
CM: "The following methods were found in the extraction:".
CM: External Coefficients.getCoefficientLift(double alpha((Angle or AngleOfAttack))) returns double((Function or Coefficient or Lift or AngleAlpha or Angle or LiftCoefficient)): "http://windTurbine/Coefficients#Coefficients.getCoefficientLift".
CM: Coefficients.getCoefficientLift has implicitInput (an ImplicitDataDescriptor with localDescriptorName "PI", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double PI = Math.PI;", with language Java)
       with declaration (a Script with script "PI = Math.PI", with language Python),
       with declaration (a Script with script "PI = tf.pi", with language Python-TF),
       with declaration (a Script with script "PI = np.pi", with language Python-NumPy))
    ,
     has expression (a Script with language Java, with script 
    "	public static double getCoefficientLift (double alpha) {

		while(alpha < -PI) {
                alpha = alpha+2*PI;
     		}

     		while(alpha > PI) {
                alpha = alpha-2*PI;
     		}
		
		if (alpha >= -PI && alpha <= -2.617993878) {
			return -4.53*alpha*alpha*alpha-43.18*alpha*alpha-134.5*alpha-136.8002-0.0331272294475;
		}
		
		if (alpha > -2.617993878 && alpha < -0.34906585) {
			return -0.1382*alpha*alpha*alpha*alpha*alpha-
					1.0964*alpha*alpha*alpha*alpha-
					3.0056*alpha*alpha*alpha-
					3.2776*alpha*alpha-
					1.788*alpha-
					1.01973983808;
		}
		
		if (alpha >= -0.34906585 && alpha <= -0.196349541) {
			return 0.345*alpha-0.5632;
		}
		
		if (alpha > -0.196349541 && alpha <= -0.161442956) {
			return -0.7268+0.04089*Math.cos(alpha*90)+
					0.06894*Math.sin(alpha*90)-
					0.00935*Math.cos(180*alpha)+
					0.01487*Math.sin(180*alpha);
		}
		
		if (alpha > -0.161442956 && alpha <= 0) {
			return 0.1978+0.5245*Math.cos(alpha*17.2)+0.9687*Math.sin(alpha*17.2)-
					0.4208*Math.cos(2*alpha*17.2)+0.06007*Math.sin(2*alpha*17.2)-
					0.016*Math.cos(3*alpha*17.2)-0.1282*Math.sin(3*alpha*17.2)+
					0.00114686568;
		}
		
		if (alpha > 0 && alpha <= 0.23536) {
			return 1.01067*(14.48*Math.sin(11.01*alpha-0.1653)+
					13.37*Math.sin(11.4*alpha+2.941)+
					0.01288*Math.sin(55.38*alpha+1.35)
					-0.01026235261);
		}
		
		if (alpha > 0.23536 && alpha <= 0.248709) {
			return 1.324566+0.01566*alpha;
		}
		
		if (alpha > 0.248709 && alpha <= 0.296706) {
			return 1.152+0.06825*Math.cos(alpha*54.38)+0.177*Math.sin(alpha*54.38)+
					0.03451*Math.cos(2*alpha*54.38)+0.004357*Math.sin(2*alpha*54.38);
		}
		
		if (alpha > 0.296706 && alpha <= 2.558) {
			return 0.2249*alpha*alpha*alpha*alpha*alpha*alpha-
					2.2324*alpha*alpha*alpha*alpha*alpha+
					8.6871*alpha*alpha*alpha*alpha-
					16.423*alpha*alpha*alpha+
					15.184*alpha*alpha-
					6.8925*alpha+2.1175079746;
		} else {
			return -0.3942-0.3309*Math.cos(alpha*4.744)+0.08493*Math.sin(alpha*4.744)
					+0.08745*Math.cos(2*alpha*4.744)-0.1064*Math.sin(2*alpha*4.744);
		}

	}"),
     has expression (a Script with language Python, with script 
    "def getCoefficientLift( alpha):
    \"\"\" generated source for method getCoefficientLift \"\"\"
    while alpha < -PI:
        alpha = alpha + 2 * PI
    while alpha > PI:
        alpha = alpha - 2 * PI
    if alpha >= -PI and alpha <= -2.617993878:
        return -4.53 * alpha * alpha * alpha - 43.18 * alpha * alpha - 134.5 * alpha - 136.8002 - 0.0331272294475
    if alpha > -2.617993878 and alpha < -0.34906585:
        return -0.1382 * alpha * alpha * alpha * alpha * alpha - 1.0964 * alpha * alpha * alpha * alpha - 3.0056 * alpha * alpha * alpha - 3.2776 * alpha * alpha - 1.788 * alpha - 1.01973983808
    if alpha >= -0.34906585 and alpha <= -0.196349541:
        return 0.345 * alpha - 0.5632
    if alpha > -0.196349541 and alpha <= -0.161442956:
        return -0.7268 + 0.04089 * Math.cos(alpha * 90) + 0.06894 * Math.sin(alpha * 90) - 0.00935 * Math.cos(180 * alpha) + 0.01487 * Math.sin(180 * alpha)
    if alpha > -0.161442956 and alpha <= 0:
        return 0.1978 + 0.5245 * Math.cos(alpha * 17.2) + 0.9687 * Math.sin(alpha * 17.2) - 0.4208 * Math.cos(2 * alpha * 17.2) + 0.06007 * Math.sin(2 * alpha * 17.2) - 0.016 * Math.cos(3 * alpha * 17.2) - 0.1282 * Math.sin(3 * alpha * 17.2) + 0.00114686568
    if alpha > 0 and alpha <= 0.23536:
        return 1.01067 * (14.48 * Math.sin(11.01 * alpha - 0.1653) + 13.37 * Math.sin(11.4 * alpha + 2.941) + 0.01288 * Math.sin(55.38 * alpha + 1.35) - 0.01026235261)
    if alpha > 0.23536 and alpha <= 0.248709:
        return 1.324566 + 0.01566 * alpha
    if alpha > 0.248709 and alpha <= 0.296706:
        return 1.152 + 0.06825 * Math.cos(alpha * 54.38) + 0.177 * Math.sin(alpha * 54.38) + 0.03451 * Math.cos(2 * alpha * 54.38) + 0.004357 * Math.sin(2 * alpha * 54.38)
    if alpha > 0.296706 and alpha <= 2.558:
        return 0.2249 * alpha * alpha * alpha * alpha * alpha * alpha - 2.2324 * alpha * alpha * alpha * alpha * alpha + 8.6871 * alpha * alpha * alpha * alpha - 16.423 * alpha * alpha * alpha + 15.184 * alpha * alpha - 6.8925 * alpha + 2.1175079746
    else:
        return -0.3942 - 0.3309 * Math.cos(alpha * 4.744) + 0.08493 * Math.sin(alpha * 4.744) + 0.08745 * Math.cos(2 * alpha * 4.744) - 0.1064 * Math.sin(2 * alpha * 4.744)
"),
     has expression (a Script with language Python-TF, with script 
    "def getCoefficientLift( alpha):
    \"\"\" generated source for method getCoefficientLift \"\"\"
    while alpha < -PI:
        alpha = alpha + 2 * PI
    while alpha > PI:
        alpha = alpha - 2 * PI
    if alpha >= -PI and alpha <= -2.617993878:
        return -4.53 * alpha * alpha * alpha - 43.18 * alpha * alpha - 134.5 * alpha - 136.8002 - 0.0331272294475
    if alpha > -2.617993878 and alpha < -0.34906585:
        return -0.1382 * alpha * alpha * alpha * alpha * alpha - 1.0964 * alpha * alpha * alpha * alpha - 3.0056 * alpha * alpha * alpha - 3.2776 * alpha * alpha - 1.788 * alpha - 1.01973983808
    if alpha >= -0.34906585 and alpha <= -0.196349541:
        return 0.345 * alpha - 0.5632
    if alpha > -0.196349541 and alpha <= -0.161442956:
        return -0.7268 + 0.04089 * tf.cos(alpha * 90) + 0.06894 * tf.sin(alpha * 90) - 0.00935 * tf.cos(180 * alpha) + 0.01487 * tf.sin(180 * alpha)
    if alpha > -0.161442956 and alpha <= 0:
        return 0.1978 + 0.5245 * tf.cos(alpha * 17.2) + 0.9687 * tf.sin(alpha * 17.2) - 0.4208 * tf.cos(2 * alpha * 17.2) + 0.06007 * tf.sin(2 * alpha * 17.2) - 0.016 * tf.cos(3 * alpha * 17.2) - 0.1282 * tf.sin(3 * alpha * 17.2) + 0.00114686568
    if alpha > 0 and alpha <= 0.23536:
        return 1.01067 * (14.48 * tf.sin(11.01 * alpha - 0.1653) + 13.37 * tf.sin(11.4 * alpha + 2.941) + 0.01288 * tf.sin(55.38 * alpha + 1.35) - 0.01026235261)
    if alpha > 0.23536 and alpha <= 0.248709:
        return 1.324566 + 0.01566 * alpha
    if alpha > 0.248709 and alpha <= 0.296706:
        return 1.152 + 0.06825 * tf.cos(alpha * 54.38) + 0.177 * tf.sin(alpha * 54.38) + 0.03451 * tf.cos(2 * alpha * 54.38) + 0.004357 * tf.sin(2 * alpha * 54.38)
    if alpha > 0.296706 and alpha <= 2.558:
        return 0.2249 * alpha * alpha * alpha * alpha * alpha * alpha - 2.2324 * alpha * alpha * alpha * alpha * alpha + 8.6871 * alpha * alpha * alpha * alpha - 16.423 * alpha * alpha * alpha + 15.184 * alpha * alpha - 6.8925 * alpha + 2.1175079746
    else:
        return -0.3942 - 0.3309 * tf.cos(alpha * 4.744) + 0.08493 * tf.sin(alpha * 4.744) + 0.08745 * tf.cos(2 * alpha * 4.744) - 0.1064 * tf.sin(2 * alpha * 4.744)
"),
     has expression (a Script with language Python-NumPy, with script 
    "def getCoefficientLift( alpha):
    \"\"\" generated source for method getCoefficientLift \"\"\"
    while alpha < -PI:
        alpha = alpha + 2 * PI
    while alpha > PI:
        alpha = alpha - 2 * PI
    if alpha >= -PI and alpha <= -2.617993878:
        return -4.53 * alpha * alpha * alpha - 43.18 * alpha * alpha - 134.5 * alpha - 136.8002 - 0.0331272294475
    if alpha > -2.617993878 and alpha < -0.34906585:
        return -0.1382 * alpha * alpha * alpha * alpha * alpha - 1.0964 * alpha * alpha * alpha * alpha - 3.0056 * alpha * alpha * alpha - 3.2776 * alpha * alpha - 1.788 * alpha - 1.01973983808
    if alpha >= -0.34906585 and alpha <= -0.196349541:
        return 0.345 * alpha - 0.5632
    if alpha > -0.196349541 and alpha <= -0.161442956:
        return -0.7268 + 0.04089 * np.cos(alpha * 90) + 0.06894 * np.sin(alpha * 90) - 0.00935 * np.cos(180 * alpha) + 0.01487 * np.sin(180 * alpha)
    if alpha > -0.161442956 and alpha <= 0:
        return 0.1978 + 0.5245 * np.cos(alpha * 17.2) + 0.9687 * np.sin(alpha * 17.2) - 0.4208 * np.cos(2 * alpha * 17.2) + 0.06007 * np.sin(2 * alpha * 17.2) - 0.016 * np.cos(3 * alpha * 17.2) - 0.1282 * np.sin(3 * alpha * 17.2) + 0.00114686568
    if alpha > 0 and alpha <= 0.23536:
        return 1.01067 * (14.48 * np.sin(11.01 * alpha - 0.1653) + 13.37 * np.sin(11.4 * alpha + 2.941) + 0.01288 * np.sin(55.38 * alpha + 1.35) - 0.01026235261)
    if alpha > 0.23536 and alpha <= 0.248709:
        return 1.324566 + 0.01566 * alpha
    if alpha > 0.248709 and alpha <= 0.296706:
        return 1.152 + 0.06825 * np.cos(alpha * 54.38) + 0.177 * np.sin(alpha * 54.38) + 0.03451 * np.cos(2 * alpha * 54.38) + 0.004357 * np.sin(2 * alpha * 54.38)
    if alpha > 0.296706 and alpha <= 2.558:
        return 0.2249 * alpha * alpha * alpha * alpha * alpha * alpha - 2.2324 * alpha * alpha * alpha * alpha * alpha + 8.6871 * alpha * alpha * alpha * alpha - 16.423 * alpha * alpha * alpha + 15.184 * alpha * alpha - 6.8925 * alpha + 2.1175079746
    else:
        return -0.3942 - 0.3309 * np.cos(alpha * 4.744) + 0.08493 * np.sin(alpha * 4.744) + 0.08745 * np.cos(2 * alpha * 4.744) - 0.1064 * np.sin(2 * alpha * 4.744)
").
CM: External Coefficients.getCoefficientDrag(double alpha((Angle or AngleOfAttack))) returns double((Function or Coefficient or Drag or AngleAlpha or Angle or DragCoefficient)): "http://windTurbine/Coefficients#Coefficients.getCoefficientDrag".
CM: Coefficients.getCoefficientDrag has implicitInput (an ImplicitDataDescriptor with localDescriptorName "PI", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double PI = Math.PI;", with language Java)
       with declaration (a Script with script "PI = Math.PI", with language Python),
       with declaration (a Script with script "PI = tf.pi", with language Python-TF),
       with declaration (a Script with script "PI = np.pi", with language Python-NumPy))
    ,
     has expression (a Script with language Java, with script 
    "	public static double getCoefficientDrag (double alpha) {

		while(alpha < -PI) {
                alpha = alpha+2*PI;
     		}

     		while(alpha > PI) {
                alpha = alpha-2*PI;
     		}
		
		if (alpha >= -PI && alpha < -0.196350) {
			return 0.661933637102-0.6336*Math.cos(alpha*1.992)-0.007707*Math.sin(alpha*1.992);
		}
		
		if (alpha >= -0.196350 && alpha < 0.296706) {
			return 18090*alpha*alpha*alpha*alpha*alpha*alpha*alpha*alpha-
					6336*alpha*alpha*alpha*alpha*alpha*alpha*alpha-
					434.3*alpha*alpha*alpha*alpha*alpha*alpha+
					269.9*alpha*alpha*alpha*alpha*alpha*+
					6.546*alpha*alpha*alpha*alpha-
					3.696*alpha*alpha*alpha+
					0.5564*alpha*alpha-
					0.01205*alpha+0.009997;
		} 
		
		if (alpha >= 0.296706 && alpha <= 0.349066) {
			return 0.7668*alpha-0.0894;
		} else {
			return 0.65978759232-0.6337*Math.cos(alpha*1.992)+0.007889*Math.sin(alpha*1.992);
		}
		

	}"),
     has expression (a Script with language Python, with script 
    "def getCoefficientDrag( alpha):
    \"\"\" generated source for method getCoefficientDrag \"\"\"
    while alpha < -PI:
        alpha = alpha + 2 * PI
    while alpha > PI:
        alpha = alpha - 2 * PI
    if alpha >= -PI and alpha < -0.196350:
        return 0.661933637102 - 0.6336 * Math.cos(alpha * 1.992) - 0.007707 * Math.sin(alpha * 1.992)
    if alpha >= -0.196350 and alpha < 0.296706:
        return 18090 * alpha * alpha * alpha * alpha * alpha * alpha * alpha * alpha - 6336 * alpha * alpha * alpha * alpha * alpha * alpha * alpha - 434.3 * alpha * alpha * alpha * alpha * alpha * alpha + 269.9 * alpha * alpha * alpha * alpha * alpha * +6.546 * alpha * alpha * alpha * alpha - 3.696 * alpha * alpha * alpha + 0.5564 * alpha * alpha - 0.01205 * alpha + 0.009997
    if alpha >= 0.296706 and alpha <= 0.349066:
        return 0.7668 * alpha - 0.0894
    else:
        return 0.65978759232 - 0.6337 * Math.cos(alpha * 1.992) + 0.007889 * Math.sin(alpha * 1.992)
"),
     has expression (a Script with language Python-TF, with script 
    "def getCoefficientDrag( alpha):
    \"\"\" generated source for method getCoefficientDrag \"\"\"
    while alpha < -PI:
        alpha = alpha + 2 * PI
    while alpha > PI:
        alpha = alpha - 2 * PI
    if alpha >= -PI and alpha < -0.196350:
        return 0.661933637102 - 0.6336 * tf.cos(alpha * 1.992) - 0.007707 * tf.sin(alpha * 1.992)
    if alpha >= -0.196350 and alpha < 0.296706:
        return 18090 * alpha * alpha * alpha * alpha * alpha * alpha * alpha * alpha - 6336 * alpha * alpha * alpha * alpha * alpha * alpha * alpha - 434.3 * alpha * alpha * alpha * alpha * alpha * alpha + 269.9 * alpha * alpha * alpha * alpha * alpha * +6.546 * alpha * alpha * alpha * alpha - 3.696 * alpha * alpha * alpha + 0.5564 * alpha * alpha - 0.01205 * alpha + 0.009997
    if alpha >= 0.296706 and alpha <= 0.349066:
        return 0.7668 * alpha - 0.0894
    else:
        return 0.65978759232 - 0.6337 * tf.cos(alpha * 1.992) + 0.007889 * tf.sin(alpha * 1.992)
"),
     has expression (a Script with language Python-NumPy, with script 
    "def getCoefficientDrag( alpha):
    \"\"\" generated source for method getCoefficientDrag \"\"\"
    while alpha < -PI:
        alpha = alpha + 2 * PI
    while alpha > PI:
        alpha = alpha - 2 * PI
    if alpha >= -PI and alpha < -0.196350:
        return 0.661933637102 - 0.6336 * np.cos(alpha * 1.992) - 0.007707 * np.sin(alpha * 1.992)
    if alpha >= -0.196350 and alpha < 0.296706:
        return 18090 * alpha * alpha * alpha * alpha * alpha * alpha * alpha * alpha - 6336 * alpha * alpha * alpha * alpha * alpha * alpha * alpha - 434.3 * alpha * alpha * alpha * alpha * alpha * alpha + 269.9 * alpha * alpha * alpha * alpha * alpha * +6.546 * alpha * alpha * alpha * alpha - 3.696 * alpha * alpha * alpha + 0.5564 * alpha * alpha - 0.01205 * alpha + 0.009997
    if alpha >= 0.296706 and alpha <= 0.349066:
        return 0.7668 * alpha - 0.0894
    else:
        return 0.65978759232 - 0.6337 * np.cos(alpha * 1.992) + 0.007889 * np.sin(alpha * 1.992)
").
Extract from "file:/C:/Users/200005201/sadl3-master2/runtime-New_configuration/Wind.clean/ExtractedModels/Sources/WindTurbine-modifiedWithReturnComment.java".
CM: "Parsing code file 'WindTurbine-modifiedWithReturnComment.java'".
CM: "The following domain ontology contribution was extracted from code comments:".
CM: TipLossCorrectionFactor is a class, described by effect with values of type Effect.
CM: PowerCoefficient is a class, described by terms with values of type Terms.
CM: CurrentBladeSegment is a class, described by radial_position with values of type RadialPosition.
CM: End is a class.
CM: RelativeWindAngle is a class.
CM: Turbine is a class, described by blades with values of type Blades.
CM: Terms is a class.
CM: Localpitchanglethetasubpsub_ortwist is a class.
CM: Number is a class, described by given_radius with values of type GivenRadius.
CM: BladeNewValues is a class, described by end with values of type End.
CM: WindTurbineAirfoil is a class, described by chord_length with values of type ChordLength.
CM: Effect is a class.
CM: Blades is a class, described by number with values of type Number.
CM: GivenRadius is a class.
CM: Power is a class, described by coefficient with values of type Coefficient.
CM: "The following methods were found in the extraction:".
CM: External WindTurbine.WindTurbine(double radius((Turbine or Radius)), int numBlades((Number or Turbine or NumOfBlades)), double tipSpeedRatio((Turbine or TipSpeedRatio or Speed))): "http://windTurbine/WindTurbine#WindTurbine.WindTurbine".
CM: WindTurbine.WindTurbine has implicitInput (an ImplicitDataDescriptor with localDescriptorName "dr", with dataType "http://www.w3.org/2001/XMLSchema#double", with augmentedType (a SemanticType with semType RadiusIncrement)
       with declaration (a Script with script "double dr = 0.05;", with language Java)
       with declaration (a Script with script "dr = 0.05", with language Python),
       with declaration (a Script with script "dr = 0.05", with language Python-TF),
       with declaration (a Script with script "dr = 0.05", with language Python-NumPy))
    ,
     has implicitOutput (an ImplicitDataDescriptor with localDescriptorName "R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double R;", with language Java)
       with declaration (a Script with script "R = 0.0", with language Python),
       with declaration (a Script with script "R = 0.0", with language Python-TF),
       with declaration (a Script with script "R = 0.0", with language Python-NumPy)),
     has implicitOutput (an ImplicitDataDescriptor with localDescriptorName "lambda_R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double lambda_R;", with language Java)
       with declaration (a Script with script "lambda_R = 0.0", with language Python),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-TF),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-NumPy)),
     has implicitOutput (an ImplicitDataDescriptor with localDescriptorName "B", with dataType "http://www.w3.org/2001/XMLSchema#int", 
       with declaration (a Script with script "int B;", with language Java)
       with declaration (a Script with script "B = 0", with language Python),
       with declaration (a Script with script "B = 0", with language Python-TF),
       with declaration (a Script with script "B = 0", with language Python-NumPy)),
     has implicitOutput (an ImplicitDataDescriptor with localDescriptorName "Omega", with dataType "http://www.w3.org/2001/XMLSchema#double", with augmentedType (a SemanticType with semType Speed,  with semType TipSpeedRatio,  with semType RotationalSpeed)
       with declaration (a Script with script "double Omega;", with language Java)
       with declaration (a Script with script "Omega = 0.0", with language Python),
       with declaration (a Script with script "Omega = 0.0", with language Python-TF),
       with declaration (a Script with script "Omega = 0.0", with language Python-NumPy)),
     has implicitOutput (an ImplicitDataDescriptor with localDescriptorName "dlambda_r", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double dlambda_r;", with language Java)
       with declaration (a Script with script "dlambda_r = 0.0", with language Python),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-TF),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-NumPy)),
     has expression (a Script with language Java, with script 
    "	public WindTurbine(double radius, int numBlades, double tipSpeedRatio) {
		this.R = radius;
		this.B = numBlades;
		this.lambda_R = tipSpeedRatio;
		this.Omega = lambda_R/R;
		this.dlambda_r = Omega*dr;
	}"),
     has expression (a Script with language Python, with script 
    "def __init__( radius, numBlades, tipSpeedRatio):
    \"\"\" generated source for method __init__ \"\"\"
    self.R = radius
    self.B = numBlades
    self.lambda_R = tipSpeedRatio
    self.Omega = lambda_R / R
    self.dlambda_r = Omega * dr
"),
     has expression (a Script with language Python-TF, with script 
    "def __init__( radius, numBlades, tipSpeedRatio):
    \"\"\" generated source for method __init__ \"\"\"
    self.R = radius
    self.B = numBlades
    self.lambda_R = tipSpeedRatio
    self.Omega = lambda_R / R
    self.dlambda_r = Omega * dr
"),
     has expression (a Script with language Python-NumPy, with script 
    "def __init__( radius, numBlades, tipSpeedRatio):
    \"\"\" generated source for method __init__ \"\"\"
    self.R = radius
    self.B = numBlades
    self.lambda_R = tipSpeedRatio
    self.Omega = lambda_R / R
    self.dlambda_r = Omega * dr
").
CM: External WindTurbine.getPowerCoefficient() returns double((Terms or Coefficient or Power or CoefficientOfPower)): "http://windTurbine/WindTurbine#WindTurbine.getPowerCoefficient".
CM: WindTurbine.getPowerCoefficient has dependsOn WindTurbine.getTwist,
     has dependsOn Coefficients.getCoefficientDrag,
     has dependsOn WindTurbine.getChordLength,
     has dependsOn Coefficients.getCoefficientLift,
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "dr", with dataType "http://www.w3.org/2001/XMLSchema#double", with augmentedType (a SemanticType with semType RadiusIncrement)
       with declaration (a Script with script "double dr = 0.05;", with language Java)
       with declaration (a Script with script "dr = 0.05", with language Python),
       with declaration (a Script with script "dr = 0.05", with language Python-TF),
       with declaration (a Script with script "dr = 0.05", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "dlambda_r", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double dlambda_r;", with language Java)
       with declaration (a Script with script "dlambda_r = 0.0", with language Python),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-TF),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "DIFF_THRESHOLD", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double DIFF_THRESHOLD = 1e-15;", with language Java)
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python-TF),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "B", with dataType "http://www.w3.org/2001/XMLSchema#int", 
       with declaration (a Script with script "int B;", with language Java)
       with declaration (a Script with script "B = 0", with language Python),
       with declaration (a Script with script "B = 0", with language Python-TF),
       with declaration (a Script with script "B = 0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "lambda_R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double lambda_R;", with language Java)
       with declaration (a Script with script "lambda_R = 0.0", with language Python),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-TF),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double R;", with language Java)
       with declaration (a Script with script "R = 0.0", with language Python),
       with declaration (a Script with script "R = 0.0", with language Python-TF),
       with declaration (a Script with script "R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "radius", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double radius = dr;", with language Java)
       with declaration (a Script with script "radius = dr", with language Python),
       with declaration (a Script with script "radius = dr", with language Python-TF),
       with declaration (a Script with script "radius = dr", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "lambda_R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double lambda_R;", with language Java)
       with declaration (a Script with script "lambda_R = 0.0", with language Python),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-TF),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "DIFF_THRESHOLD", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double DIFF_THRESHOLD = 1e-15;", with language Java)
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python-TF),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "PI", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double PI = Math.PI;", with language Java)
       with declaration (a Script with script "PI = Math.PI", with language Python),
       with declaration (a Script with script "PI = tf.pi", with language Python-TF),
       with declaration (a Script with script "PI = np.pi", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "e", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double e = Math.E;", with language Java)
       with declaration (a Script with script "e = Math.E", with language Python),
       with declaration (a Script with script "e = tf.e", with language Python-TF),
       with declaration (a Script with script "e = np.e", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "Omega", with dataType "http://www.w3.org/2001/XMLSchema#double", with augmentedType (a SemanticType with semType Speed,  with semType TipSpeedRatio,  with semType RotationalSpeed)
       with declaration (a Script with script "double Omega;", with language Java)
       with declaration (a Script with script "Omega = 0.0", with language Python),
       with declaration (a Script with script "Omega = 0.0", with language Python-TF),
       with declaration (a Script with script "Omega = 0.0", with language Python-NumPy))
    ,
     has expression (a Script with language Java, with script 
    "	public double getPowerCoefficient () {
		
		// Let C_Ptot be the running sum for the coefficient of power
		double C_Ptot = 0;
		double lambda_r;
		double phi;
			
		double alpha;
		double C_L;
		double C_D;
		double C_t;
		double C_n;
		double sigmaPrime;
		double a_next;
		double aPrime_next;
		double aPrime;
		double a;
		double F_tilde;
		double f;
		double F;
		
		System.out.println(\"------------Intermediary Values-------------\");
		System.out.println(\"radial position(m)\ta\t\t\taPrime\");

		for (double radius = dr; radius <= R; radius += dr) {

			//---------Calculate a and aPrime at current radial position-----------

			// Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
			lambda_r = Omega*radius;
			phi = 0;
			
			// Look up C_d(alpha) and C_l(alpha) from the Coefficients class
			sigmaPrime = B * getChordLength(radius) /(2*PI*radius); // Calculate local solidity
			a_next = 1./3;
			aPrime_next = 0.0;
			aPrime = 1;
			a = 1;
			F_tilde = 0;
			

			// Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
			while (Math.abs(a_next-a) > DIFF_THRESHOLD && Math.abs(aPrime_next-aPrime) > DIFF_THRESHOLD) {
				
				/* Set the current values of a and aPrime to the values of a and aPrime calculated
				 * in the previous iteration.
				 */
				a = a_next;
				aPrime = aPrime_next;
				
				// Calculate angle between reference plane and relative wind
				phi = Math.atan((1-a)/(lambda_r*(1+aPrime)));
				
				// Calculate angle of attack, defined as angle between chord line and relative wind
				alpha = phi - getTwist(radius);
				
				// Look up C_d(alpha) and C_l(alpha)
				C_L = Coefficients.getCoefficientLift(alpha);
				C_D = Coefficients.getCoefficientDrag(alpha);
				C_t = C_L*Math.sin(phi) - C_D*Math.cos(phi);
				C_n = C_L*Math.cos(phi) + C_D*Math.sin(phi);
				
				// Calculate tip loss correction factor
				f = B*(R-radius)/(2*radius*Math.sin(phi));
				F = 2/PI*Math.acos(Math.pow(e, -f));
				F_tilde = F*Math.max(1.0, (1-a/4*(5-3*a))/(1-a));
				
				/* Cancel the effect of the tip loss correction factor 
				 * if the current segment is at the end of the blade
				 */
				if (Math.abs(R-radius)<1e-6 || Double.isNaN(F_tilde)) {
					F_tilde = 1;
					F = 1;
				}
				
				// Calculate the new values of a and aPrime
				a_next = 1/(4*F_tilde*(Math.sin(phi))*(Math.sin(phi))/(C_n*sigmaPrime) + 1);
				aPrime_next = 1/(4*F*(Math.sin(phi))*(Math.cos(phi))/(C_t*sigmaPrime) - 1);
			}
			
			System.out.printf(\"%.2f\t\t\t\" + \"%.6f\t\t\" + \"%.6f\n\", radius, a_next, aPrime_next);
			

			//--------Calculate dC_P and add it to the running sum for the power coefficient---------
			
			C_Ptot += 8/(lambda_R*lambda_R)*F_tilde*aPrime*(1-a)*lambda_r*lambda_r*lambda_r*dlambda_r;
			
		}
		
		//--------Return the total sum of all the C_P contributions from each blade segment---------
		
		return C_Ptot*100;

	}"),
     has expression (a Script with language Python, with script 
    "def getPowerCoefficient():
    \"\"\" generated source for method getPowerCoefficient \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        F_tilde = 0
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while Math.abs(a_next - a) > DIFF_THRESHOLD and Math.abs(aPrime_next - aPrime) > DIFF_THRESHOLD:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = Math.atan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * Math.sin(phi) - C_D * Math.cos(phi)
            C_n = C_L * Math.cos(phi) + C_D * Math.sin(phi)
            # // Calculate tip loss correction factor
            f = B * (R - radius) / (2 * radius * Math.sin(phi))
            F = 2 / PI * Math.acos(Math.pow(e, -f))
            F_tilde = F * Math.max(1.0, (1 - a / 4 * (5 - 3 * a)) / (1 - a))
            # /* Cancel the effect of the tip loss correction factor 
            # 				 * if the current segment is at the end of the blade
            # 				 */
            if Math.abs(R - radius) < 1e-6 or Double.isNaN(F_tilde):
                F_tilde = 1
                F = 1
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * F_tilde * (Math.sin(phi)) * (Math.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * F * (Math.sin(phi)) * (Math.cos(phi)) / (C_t * sigmaPrime) - 1)
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * F_tilde * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate tip loss correction factor
    # /* Cancel the effect of the tip loss correction factor 
    # 				 * if the current segment is at the end of the blade
    # 				 */
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
"),
     has expression (a Script with language Python-TF, with script 
    "def getPowerCoefficient():
    \"\"\" generated source for method getPowerCoefficient \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        F_tilde = 0
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while tf.abs(a_next - a) > DIFF_THRESHOLD and tf.abs(aPrime_next - aPrime) > DIFF_THRESHOLD:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = tf.atan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * tf.sin(phi) - C_D * tf.cos(phi)
            C_n = C_L * tf.cos(phi) + C_D * tf.sin(phi)
            # // Calculate tip loss correction factor
            f = B * (R - radius) / (2 * radius * tf.sin(phi))
            F = 2 / PI * tf.acos(tf.pow(e, -f))
            F_tilde = F * tf.maximum(1.0, (1 - a / 4 * (5 - 3 * a)) / (1 - a))
            # /* Cancel the effect of the tip loss correction factor 
            # 				 * if the current segment is at the end of the blade
            # 				 */
            if tf.abs(R - radius) < 1e-6 or tf.is_nan(F_tilde):
                F_tilde = 1
                F = 1
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * F_tilde * (tf.sin(phi)) * (tf.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * F * (tf.sin(phi)) * (tf.cos(phi)) / (C_t * sigmaPrime) - 1)
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * F_tilde * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate tip loss correction factor
    # /* Cancel the effect of the tip loss correction factor 
    # 				 * if the current segment is at the end of the blade
    # 				 */
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
"),
     has expression (a Script with language Python-NumPy, with script 
    "def getPowerCoefficient():
    \"\"\" generated source for method getPowerCoefficient \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        F_tilde = 0
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while np.abs(a_next - a) > DIFF_THRESHOLD and np.abs(aPrime_next - aPrime) > DIFF_THRESHOLD:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = np.arctan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * np.sin(phi) - C_D * np.cos(phi)
            C_n = C_L * np.cos(phi) + C_D * np.sin(phi)
            # // Calculate tip loss correction factor
            f = B * (R - radius) / (2 * radius * np.sin(phi))
            F = 2 / PI * np.arccos(np.power(e, -f))
            F_tilde = F * np.maximum(1.0, (1 - a / 4 * (5 - 3 * a)) / (1 - a))
            # /* Cancel the effect of the tip loss correction factor 
            # 				 * if the current segment is at the end of the blade
            # 				 */
            if np.abs(R - radius) < 1e-6 or np.isnan(F_tilde):
                F_tilde = 1
                F = 1
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * F_tilde * (np.sin(phi)) * (np.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * F * (np.sin(phi)) * (np.cos(phi)) / (C_t * sigmaPrime) - 1)
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * F_tilde * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate tip loss correction factor
    # /* Cancel the effect of the tip loss correction factor 
    # 				 * if the current segment is at the end of the blade
    # 				 */
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
").
CM: External WindTurbine.getTwist(double pos((RadialPosition or CurrentBladeSegment))) returns double((Twist or CurrentBladeSegment or Angle)): "http://windTurbine/WindTurbine#WindTurbine.getTwist".
CM: WindTurbine.getTwist has implicitInput (an ImplicitDataDescriptor with localDescriptorName "R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double R;", with language Java)
       with declaration (a Script with script "R = 0.0", with language Python),
       with declaration (a Script with script "R = 0.0", with language Python-TF),
       with declaration (a Script with script "R = 0.0", with language Python-NumPy))
    ,
     has expression (a Script with language Java, with script 
    "	private double getTwist (double pos) {

		return 0.02*3/R*Math.log(pos)/Math.log(0.3);
		
	}"),
     has expression (a Script with language Python, with script 
    "def getTwist( pos):
    \"\"\" generated source for method getTwist \"\"\"
    return 0.02 * 3 / R * Math.log(pos) / Math.log(0.3)
"),
     has expression (a Script with language Python-TF, with script 
    "def getTwist( pos):
    \"\"\" generated source for method getTwist \"\"\"
    return 0.02 * 3 / R * tf.log(pos) / tf.log(0.3)
"),
     has expression (a Script with language Python-NumPy, with script 
    "def getTwist( pos):
    \"\"\" generated source for method getTwist \"\"\"
    return 0.02 * 3 / R * np.log(pos) / np.log(0.3)
").
CM: External WindTurbine.getChordLength(double pos((RadialPosition or CurrentBladeSegment))) returns double((Length or CurrentBladeSegment or ChordLength)): "http://windTurbine/WindTurbine#WindTurbine.getChordLength".
CM: WindTurbine.getChordLength has implicitInput (an ImplicitDataDescriptor with localDescriptorName "R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double R;", with language Java)
       with declaration (a Script with script "R = 0.0", with language Python),
       with declaration (a Script with script "R = 0.0", with language Python-TF),
       with declaration (a Script with script "R = 0.0", with language Python-NumPy))
    ,
     has expression (a Script with language Java, with script 
    "	private double getChordLength (double pos) {

		return R/15-3.0/50*pos;

	}"),
     has expression (a Script with language Python, with script 
    "def getChordLength( pos):
    \"\"\" generated source for method getChordLength \"\"\"
    return R / 15 - 3.0 / 50 * pos
"),
     has expression (a Script with language Python-TF, with script 
    "def getChordLength( pos):
    \"\"\" generated source for method getChordLength \"\"\"
    return R / 15 - 3.0 / 50 * pos
"),
     has expression (a Script with language Python-NumPy, with script 
    "def getChordLength( pos):
    \"\"\" generated source for method getChordLength \"\"\"
    return R / 15 - 3.0 / 50 * pos
").
CM: External WindTurbine.getPowerCoefficientNoTip (note "returns Return the total sum of all the C_P contributions from each blade segment")() returns double: "http://windTurbine/WindTurbine#WindTurbine.getPowerCoefficientNoTip".
CM: What type does WindTurbine.getPowerCoefficientNoTip return?
CM: WindTurbine.getPowerCoefficientNoTip has dependsOn WindTurbine.getTwist,
     has dependsOn WindTurbine.getChordLength,
     has dependsOn Coefficients.getCoefficientDrag,
     has dependsOn Coefficients.getCoefficientLift,
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "lambda_R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double lambda_R;", with language Java)
       with declaration (a Script with script "lambda_R = 0.0", with language Python),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-TF),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "dlambda_r", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double dlambda_r;", with language Java)
       with declaration (a Script with script "dlambda_r = 0.0", with language Python),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-TF),
       with declaration (a Script with script "dlambda_r = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "DIFF_THRESHOLD", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double DIFF_THRESHOLD = 1e-15;", with language Java)
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python-TF),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "PI", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double PI = Math.PI;", with language Java)
       with declaration (a Script with script "PI = Math.PI", with language Python),
       with declaration (a Script with script "PI = tf.pi", with language Python-TF),
       with declaration (a Script with script "PI = np.pi", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "DIFF_THRESHOLD", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double DIFF_THRESHOLD = 1e-15;", with language Java)
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python-TF),
       with declaration (a Script with script "DIFF_THRESHOLD = 1e-15", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "B", with dataType "http://www.w3.org/2001/XMLSchema#int", 
       with declaration (a Script with script "int B;", with language Java)
       with declaration (a Script with script "B = 0", with language Python),
       with declaration (a Script with script "B = 0", with language Python-TF),
       with declaration (a Script with script "B = 0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "radius", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double radius = dr;", with language Java)
       with declaration (a Script with script "radius = dr", with language Python),
       with declaration (a Script with script "radius = dr", with language Python-TF),
       with declaration (a Script with script "radius = dr", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "dr", with dataType "http://www.w3.org/2001/XMLSchema#double", with augmentedType (a SemanticType with semType RadiusIncrement)
       with declaration (a Script with script "double dr = 0.05;", with language Java)
       with declaration (a Script with script "dr = 0.05", with language Python),
       with declaration (a Script with script "dr = 0.05", with language Python-TF),
       with declaration (a Script with script "dr = 0.05", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "Omega", with dataType "http://www.w3.org/2001/XMLSchema#double", with augmentedType (a SemanticType with semType Speed,  with semType TipSpeedRatio,  with semType RotationalSpeed)
       with declaration (a Script with script "double Omega;", with language Java)
       with declaration (a Script with script "Omega = 0.0", with language Python),
       with declaration (a Script with script "Omega = 0.0", with language Python-TF),
       with declaration (a Script with script "Omega = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "lambda_R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double lambda_R;", with language Java)
       with declaration (a Script with script "lambda_R = 0.0", with language Python),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-TF),
       with declaration (a Script with script "lambda_R = 0.0", with language Python-NumPy)),
     has implicitInput (an ImplicitDataDescriptor with localDescriptorName "R", with dataType "http://www.w3.org/2001/XMLSchema#double", 
       with declaration (a Script with script "double R;", with language Java)
       with declaration (a Script with script "R = 0.0", with language Python),
       with declaration (a Script with script "R = 0.0", with language Python-TF),
       with declaration (a Script with script "R = 0.0", with language Python-NumPy))
    ,
     has expression (a Script with language Java, with script 
    "	public double getPowerCoefficientNoTip () {
		
		// Let C_Ptot be the running sum for the coefficient of power
		double C_Ptot = 0;
		double lambda_r;
		double phi;
			
		double alpha;
		double C_L;
		double C_D;
		double C_t;
		double C_n;
		double sigmaPrime;
		double a_next;
		double aPrime_next;
		double aPrime;
		double a;
		double F_tilde;
		double f;
		double F;

		
		System.out.println(\"------------Intermediary Values-------------\");
		System.out.println(\"radial position(m)\ta\t\t\taPrime\");

		for (double radius = dr; radius <= R; radius += dr) {

			//---------Calculate a and aPrime at current radial position-----------

			// Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
			lambda_r = Omega*radius;
			phi = 0;
			
			// Look up C_d(alpha) and C_l(alpha) from the Coefficients class
			sigmaPrime = B * getChordLength(radius) /(2*PI*radius); // Calculate local solidity
			a_next = 1./3;
			aPrime_next = 0.0;
			aPrime = 1;
			a = 1;
			

			// Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
			while (Math.abs(a_next-a) > DIFF_THRESHOLD && Math.abs(aPrime_next-aPrime) > DIFF_THRESHOLD) {
				
				/* Set the current values of a and aPrime to the values of a and aPrime calculated
				 * in the previous iteration.
				 */
				a = a_next;
				aPrime = aPrime_next;
				
				// Calculate angle between reference plane and relative wind
				phi = Math.atan((1-a)/(lambda_r*(1+aPrime)));
				
				// Calculate angle of attack, defined as angle between chord line and relative wind
				alpha = phi - getTwist(radius);
				
				// Look up C_d(alpha) and C_l(alpha)
				C_L = Coefficients.getCoefficientLift(alpha);
				C_D = Coefficients.getCoefficientDrag(alpha);
				C_t = C_L*Math.sin(phi) - C_D*Math.cos(phi);
				C_n = C_L*Math.cos(phi) + C_D*Math.sin(phi);
				
				// Calculate the new values of a and aPrime
				a_next = 1/(4*(Math.sin(phi))*(Math.sin(phi))/(C_n*sigmaPrime) + 1);
				aPrime_next = 1/(4*(Math.sin(phi))*(Math.cos(phi))/(C_t*sigmaPrime) - 1);
			}
			
			System.out.printf(\"%.2f\t\t\t\" + \"%.6f\t\t\" + \"%.6f\n\", radius, a_next, aPrime_next);
			

			//--------Calculate dC_P and add it to the running sum for the power coefficient---------
			
			C_Ptot += 8/(lambda_R*lambda_R)*aPrime*(1-a)*lambda_r*lambda_r*lambda_r*dlambda_r;
			
		}
		
		//--------Return the total sum of all the C_P contributions from each blade segment---------
		
		return C_Ptot*100;	// Return the total sum of all the C_P contributions from each blade segment

	}"),
     has expression (a Script with language Python, with script 
    "def getPowerCoefficientNoTip():
    \"\"\" generated source for method getPowerCoefficientNoTip \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while Math.abs(a_next - a) > DIFF_THRESHOLD and Math.abs(aPrime_next - aPrime) > DIFF_THRESHOLD:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = Math.atan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * Math.sin(phi) - C_D * Math.cos(phi)
            C_n = C_L * Math.cos(phi) + C_D * Math.sin(phi)
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * (Math.sin(phi)) * (Math.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * (Math.sin(phi)) * (Math.cos(phi)) / (C_t * sigmaPrime) - 1)
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
    # // Return the total sum of all the C_P contributions from each blade segment
"),
     has expression (a Script with language Python-TF, with script 
    "def getPowerCoefficientNoTip():
    \"\"\" generated source for method getPowerCoefficientNoTip \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while tf.abs(a_next - a) > DIFF_THRESHOLD and tf.abs(aPrime_next - aPrime) > DIFF_THRESHOLD:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = tf.atan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * tf.sin(phi) - C_D * tf.cos(phi)
            C_n = C_L * tf.cos(phi) + C_D * tf.sin(phi)
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * (tf.sin(phi)) * (tf.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * (tf.sin(phi)) * (tf.cos(phi)) / (C_t * sigmaPrime) - 1)
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
    # // Return the total sum of all the C_P contributions from each blade segment
"),
     has expression (a Script with language Python-NumPy, with script 
    "def getPowerCoefficientNoTip():
    \"\"\" generated source for method getPowerCoefficientNoTip \"\"\"
    #  Let C_Ptot be the running sum for the coefficient of power
    C_Ptot = 0
    lambda_r = 0.0
    phi = 0.0
    alpha = 0.0
    C_L = 0.0
    C_D = 0.0
    C_t = 0.0
    C_n = 0.0
    sigmaPrime = 0.0
    a_next = 0.0
    aPrime_next = 0.0
    aPrime = 0.0
    a = 0.0
    F_tilde = 0.0
    f = 0.0
    F = 0.0
    
    
    # // Let C_Ptot be the running sum for the coefficient of power
    radius = dr
    while radius <= R:
        # // Let C_Ptot be the running sum for the coefficient of power
        # //---------Calculate a and aPrime at current radial position-----------
        # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
        lambda_r = Omega * radius
        phi = 0
        # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
        sigmaPrime = B * getChordLength(radius) / (2 * PI * radius)
        # // Calculate local solidity
        a_next = 1. / 3
        aPrime_next = 0.0
        aPrime = 1
        a = 1
        # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
        while np.abs(a_next - a) > DIFF_THRESHOLD and np.abs(aPrime_next - aPrime) > DIFF_THRESHOLD:
            # /* Set the current values of a and aPrime to the values of a and aPrime calculated
            # 				 * in the previous iteration.
            # 				 */
            a = a_next
            aPrime = aPrime_next
            # // Calculate angle between reference plane and relative wind
            phi = np.arctan((1 - a) / (lambda_r * (1 + aPrime)))
            # // Calculate angle of attack, defined as angle between chord line and relative wind
            alpha = phi - getTwist(radius)
            # // Look up C_d(alpha) and C_l(alpha)
            C_L = Coefficients.getCoefficientLift(alpha)
            C_D = Coefficients.getCoefficientDrag(alpha)
            C_t = C_L * np.sin(phi) - C_D * np.cos(phi)
            C_n = C_L * np.cos(phi) + C_D * np.sin(phi)
            # // Calculate the new values of a and aPrime
            a_next = 1 / (4 * (np.sin(phi)) * (np.sin(phi)) / (C_n * sigmaPrime) + 1)
            aPrime_next = 1 / (4 * (np.sin(phi)) * (np.cos(phi)) / (C_t * sigmaPrime) - 1)
        
        # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
        C_Ptot += 8 / (lambda_R * lambda_R) * aPrime * (1 - a) * lambda_r * lambda_r * lambda_r * dlambda_r
        radius += dr
    # //---------Calculate a and aPrime at current radial position-----------
    # // Step 1: Guess a (axial induction factor) and aPrime (angular induction factor)
    # // Look up C_d(alpha) and C_l(alpha) from the Coefficients class
    # // Calculate local solidity
    # // Step 2: Allow a and aPrime to converge to their true values (within the difference threshold)
    # /* Set the current values of a and aPrime to the values of a and aPrime calculated
    # 				 * in the previous iteration.
    # 				 */
    # // Calculate angle between reference plane and relative wind
    # // Calculate angle of attack, defined as angle between chord line and relative wind
    # // Look up C_d(alpha) and C_l(alpha)
    # // Calculate the new values of a and aPrime
    # //--------Calculate dC_P and add it to the running sum for the power coefficient---------
    # //--------Return the total sum of all the C_P contributions from each blade segment---------
    return C_Ptot * 100
    # // Return the total sum of all the C_P contributions from each blade segment
").
